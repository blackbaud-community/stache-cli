#!/usr/bin/env node

/**
* Why such a small file?  In almost all cases, this is simply a shim for grunt.
* We kept grunt in order to better support TFS / Visual Studio development (surprising right?)
**/

'use strict';

// Libraries
var fs = require('fs');
var path = require('path');
var shell = require('child_process').exec;
var cli = path.normalize(__dirname + '/../');
var cwd = path.normalize(process.cwd() + '/');

var gruntconfig = 'gruntfile.js';
var isPrepare = process.argv.length > 2 && process.argv[2] === 'prepare';
var isVersion = process.argv.length > 2 && process.argv[2] === 'cli-version';
var isLocal = fs.existsSync(cwd + gruntconfig);
var gruntfile = ((!isPrepare && isLocal && isVersion) ? cwd : cli) + gruntconfig;
var options = {
  cwd : cwd,
  maxBuffer: 1048576
};
var commands = [];
var flags = [
  '--color',
  '--cli=' + cli,
  '--cwd=' + cwd,
  '--gruntfile=' + gruntfile,
  '--base=' + ((!isPrepare && isLocal && isVersion) ? cwd : cli)
];

// Split command line options into grunt commands vs flags, ignores first two as they're node paths
process.argv.slice(2).forEach(function(item) {
  if (item.indexOf('--') === 0) {
    flags.push(item);
  } else {
    commands.push(item);
  }
});

// Build the shell command we're going to run
var run = [
  'grunt',
  commands.join(':'),
  flags.join(' ')
];

// Execute shell command
var grunt = shell(run.join(' '), options);

// Event Listening
grunt.stdout.on('data', function(d) { process.stdout.write(d); });
grunt.stderr.on('data', function(d) { process.stderr.write(d); });
grunt.on('error', function(e) { console.log(e) });
